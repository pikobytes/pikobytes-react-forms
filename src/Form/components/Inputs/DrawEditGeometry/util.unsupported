/**
 * Created by nicolas.looschen@pikobytes.de on 23/11/20.
 *
 * This file is subject to the terms and conditions defined in
 * file 'LICENSE.txt', which is part of this source code package.
 */
import { lineString, polygon } from '@turf/helpers';
import { along, centerOfMass, length } from '@turf/turf';
import { GEOMETRY_TYPES, IFeature } from './typedef/types';

/**
 * creates a feature representation from coordinates (for linestrings or polygons)
 */
export function createFeatureFromCoordinates(
  type: string,
  coordinates: number[][] | number[][][]
) {
  return {
    type: 'Feature',
    properties: {},
    id: 'geometry',
    geometry: {
      type,
      coordinates,
    },
  };
}

/**
 * creates a feature representation from a point
 * @param point
 */
export function createFeatureFromPoint(point: Array<number>) {
  return {
    type: 'Feature',
    properties: {},
    id: 'geometry',
    geometry: {
      type: GEOMETRY_TYPES.POINT,
      coordinates: point,
    },
  };
}

export function createFeatureFromPointString(point: Array<string>) {
  return createFeatureFromPoint(point.map((p) => parseFloat(p)));
}

export function pointToFixed(
  point: [x: number, y: number],
  fractionDigits = 5
) {
  const [lng, lat] = pointToFixedString(point, fractionDigits);

  return [+lng, +lat];
}

export function pointToFixedString(
  point: [x: number, y: number],
  fractionDigits = 5
) {
  const [x, y] = point;
  const lng = x === undefined ? '0' : x.toFixed(fractionDigits);
  const lat = y === undefined ? '0' : y.toFixed(fractionDigits);

  return [lng, lat];
}

export function getCenterFromPoints(
  type: string,
  points: Array<number[]> | Array<number[][]>
): Array<number> {
  switch (type) {
    case GEOMETRY_TYPES.LINE:
      const pointsLine = points as Array<number[]>;
      const line = lineString(pointsLine);
      return along(line, length(line) / 2).geometry!.coordinates;
    case GEOMETRY_TYPES.POLYGON:
      const linearRingsArray = points as Array<number[][]>;
      const poly = polygon(linearRingsArray);
      return centerOfMass(poly).geometry!.coordinates;
    default:
      const otherPoints = points as Array<number[]>;
      return otherPoints[0];
  }
}

export function getDrawHandlerNameFromGeometryType(
  geometryType: GEOMETRY_TYPES
) {
  switch (geometryType) {
    case GEOMETRY_TYPES.POINT:
      return 'draw_point';
    case GEOMETRY_TYPES.LINE:
      return 'draw_line_string';
    case GEOMETRY_TYPES.POLYGON:
      return 'draw_polygon';
    default:
      return 'simple_select';
  }
}

export function handleUpdateGeometry(
  newFeature: IFeature,
  changeCallback: (newGeometry: string) => void
) {
  let points: number[] | number[][] | number[][][];
  if (newFeature.geometry.type === GEOMETRY_TYPES.POINT) {
    points = pointToFixed(
      newFeature.geometry.coordinates as [lng: number, lat: number]
    );
  } else if (newFeature.geometry.type === GEOMETRY_TYPES.LINE) {
    points = newFeature.geometry.coordinates.slice(0) as number[][];
    points = points.map((point: [x: number, y: number]) => pointToFixed(point));
  } else {
    points = (newFeature.geometry.coordinates.slice(
      0
    ) as unknown) as number[][][];
    points = [
      points[0].map((point: [x: number, y: number]) => pointToFixed(point)),
    ];
  }

  changeCallback(
    JSON.stringify({
      type: newFeature.geometry.type,
      coordinates: points,
    })
  );
}

export function isNumber(input: string) {
  const n = Number(input);
  return !isNaN(n);
}

export function isValidPoint(point: [lng: string, lat: string]) {
  const lng = parseFloat(point[0]);
  const lat = parseFloat(point[1]);

  if (lng > 180 || lng < -180) return false;
  if (lat > 90 || lat < -90) return false;

  return true;
}
