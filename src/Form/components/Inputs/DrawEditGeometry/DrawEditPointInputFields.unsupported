/**
 * Created by nicolas.looschen@pikobytes.de on 3/26/21.
 *
 * This file is subject to the terms and conditions defined in
 * file 'LICENSE.txt', which is part of this source code package.
 */

import React, { ChangeEvent, useEffect, useState } from 'react';
import { alpha, createStyles, Grid, TextField, Theme } from '@material-ui/core';
import { makeStyles } from '@material-ui/styles';
import { UseFormReturn } from 'react-hook-form';
import { useThrottleCallback } from '@react-hook/throttle';
import { useRecoilValue } from 'recoil';
import clsx from 'clsx';

import { DRAW_EDIT_GEOMETRY_NAMESPACE, IGeometry } from './typedef/types';
import {
  createFeatureFromPointString,
  handleUpdateGeometry,
  isNumber,
  isValidPoint,
  pointToFixedString,
} from './util';
import { translationFunctionState } from '../../../../structs/atoms';
import { generateTranslate } from '../../../../util/translation';

enum E_INPUT_FIELDS {
  lat = 'lat',
  lng = 'lng',
}

const useStyles = makeStyles((theme: Theme) =>
  createStyles({
    highlightedBackground: {
      backgroundColor: alpha(theme.palette.error.light, 0.35),
    },
  })
);

interface DrawEditPointInputFieldsProps {
  error?: { message: string; type: string };
  name: string;
  onChange: (value: string) => void;
  onResetError: UseFormReturn['clearErrors'];
  onSetError: UseFormReturn['setError'];
  required?: boolean;
  geometry: IGeometry;
  variant?: 'filled' | 'outlined' | 'standard';
}

export default function DrawEditPointInputFields(
  props: DrawEditPointInputFieldsProps
) {
  const {
    error,
    geometry,
    name,
    onChange,
    onResetError,
    onSetError,
    required,
    variant,
  } = props;

  // state section
  const classes = useStyles();
  // internal (-> state of the input fields) point
  const [internalPoint, setInternalPoint] = useState<[string, string]>([
    '',
    '',
  ]);
  // is the user typing in the input fields? -> try to display internal
  // point representation
  const [isTyping, setIsTyping] = useState(false);
  const t = useRecoilValue(translationFunctionState);
  const DRAW_EDIT_POINT_INPUT_NAMESPACE =
    'application:component.DrawEditPointInput';

  const translate = generateTranslate(t);
  const [lng, lat] = internalPoint;
  const isErroneous = error !== undefined;

  const latLabel = translate(
    `${DRAW_EDIT_POINT_INPUT_NAMESPACE}.latitude.label`,
    'lat'
  );
  const latPlaceholder = translate(
    `${DRAW_EDIT_POINT_INPUT_NAMESPACE}.latitude.placeholder`
  ) as string;

  const lngLabel = translate(
    `${DRAW_EDIT_POINT_INPUT_NAMESPACE}.longitude.label`,
    'lon'
  );
  const lngPlaceholder = translate(
    `${DRAW_EDIT_POINT_INPUT_NAMESPACE}.longitude.placeholder`
  ) as string;

  // handlers
  const generateHandleChange = (inputField: E_INPUT_FIELDS) => (
    event: ChangeEvent<HTMLTextAreaElement>
  ) => {
    let newInternalPoint: [string, string];

    // determine new value
    if (inputField === E_INPUT_FIELDS.lat) {
      newInternalPoint = [`${lng}`, `${event.target.value}`];
    } else {
      newInternalPoint = [`${event.target.value}`, `${lat}`];
    }

    // set error if the value is not a number
    if (!isNumber(newInternalPoint[0]) || !isNumber(newInternalPoint[1])) {
      onSetError(name, {
        type: 'manual',
        message: translate(
          `${DRAW_EDIT_GEOMETRY_NAMESPACE}.onlyNumerical`,
          'Only numerical input is allowed.'
        ) as string,
      });
    } else if (!isValidPoint(newInternalPoint)) {
      onSetError(name, {
        type: 'manual',
        message: translate(
          `${DRAW_EDIT_GEOMETRY_NAMESPACE}.rangeViolated`,
          'The range for latitude or longitude is violated.'
        ) as string,
      });
    } else {
      // reset error when the input change
      if (error !== undefined) {
        onResetError(name);
      }
      const newFeature = createFeatureFromPointString(newInternalPoint);
      handleUpdateGeometry(newFeature, onChange);
    }

    // update Value
    setInternalPoint(newInternalPoint);
  };

  const handleBlur = () => {
    // signalize editing process has stopped
    setIsTyping(false);

    if (internalPoint[0] === '' && internalPoint[1] === '') {
      return;
    }

    // if there is a valid geometry propagate it to the form state
    if (
      isNumber(internalPoint[0]) &&
      isNumber(internalPoint[1]) &&
      isValidPoint(internalPoint)
    ) {
      const newFeature = createFeatureFromPointString(internalPoint);
      handleUpdateGeometry(newFeature, onChange);
    } else {
      // else set an error message (but do not override existing ones)
      if (error === undefined) {
        onSetError(name, {
          type: 'manual',
          message: translate(
            `${DRAW_EDIT_GEOMETRY_NAMESPACE}.invalidGeometry`,
            'Invalid geometry.'
          ) as string,
        });
      }
    }
  };

  const handleFocus = () => {
    setIsTyping(true);
  };

  const handleUpdateExternalGeometry = useThrottleCallback(() => {
    const { coordinates } = geometry;

    if (!isTyping) {
      if (coordinates.length > 0) {
        setInternalPoint(
          pointToFixedString(coordinates as [number, number]) as [
            string,
            string
          ]
        );
      } else {
        setInternalPoint(['', '']);
      }

      if (error !== undefined) {
        onResetError(name);
      }
    }
  });

  useEffect(handleUpdateExternalGeometry, [geometry]);

  return (
    <Grid container alignItems="flex-end" spacing={2}>
      <Grid item xs={6}>
        <TextField
          className={clsx(
            required && lat === '' && classes.highlightedBackground
          )}
          error={isErroneous}
          fullWidth
          InputLabelProps={{ shrink: true }}
          label={latLabel}
          onBlur={handleBlur}
          onChange={generateHandleChange(E_INPUT_FIELDS.lat)}
          onFocus={handleFocus}
          placeholder={latPlaceholder}
          required={required}
          value={lat}
          variant={variant}
        />
      </Grid>
      <Grid item xs={6}>
        <TextField
          className={clsx(
            required && lng === '' && classes.highlightedBackground
          )}
          error={isErroneous}
          fullWidth
          InputLabelProps={{ shrink: true }}
          label={lngLabel}
          onBlur={handleBlur}
          onChange={generateHandleChange(E_INPUT_FIELDS.lng)}
          onFocus={handleFocus}
          placeholder={lngPlaceholder}
          required={required}
          value={lng}
          variant={variant}
        />
      </Grid>
    </Grid>
  );
}
